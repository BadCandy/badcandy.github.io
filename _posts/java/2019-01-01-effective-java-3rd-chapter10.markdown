---
layout: post
title:  "Effective Java 3rd - Chapter10. 예외"
date:   2019-01-01 01:11:00
categories: java
comments: true
---
* content
{:toc}

### Item 69. 예외는 진짜 예외 상황에서만 사용하라
배열의 원소를 모두 순회한후 반복문에서 빠져나오기 위해 다음과 깉이 예외 처리한 코드를 보자.

```java
try {
	int i = 0;
	while (true) {
		range[i++].clumb();
	}
} catch (ArrayIndexOutOfBoundsException e) {

}
```

코드의 의도는 배열의 원소를 모두 순회했는지 체크하는 중복 if문을 생략하면 성능이 더 좋아질 것이라고 기대하여 위와 같이 작성했을 것이다. 엄연히 말해서 다음의 이유로 잘못된 추론이다.
1. 코드를 `try-catch` 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
2. 배열을 순회하는 표준 관용구는 앞서 걱정한 if문 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.
3. `try-catch` 안에 다른 배열을 사용하는 코드가 있고 그 부분에서 `ArrayIndexOutOfBoundsException`이 발생했다면 위의 코드를 사용하는 메서드는 오동작을 일으킬 것이다.

**그러므로 예외는 오직 예외 상황에서만 사용해야 하고, 클라이언트 API에게 정상적인 제어 흐름에서 예외 처리를 강요하는 API 설계를 하지말아야 한다.**
<br><br>

### Item 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
**호출하는 쪽에서 복구하리라 여겨지는 상황이라면 `검사 예외`를 사용하라.** API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구한 것이다. 검사 예외를 사용한다면 API 사용자가 복구할 수 있도록 복구에 필요한 정보를 알려주는 메서드를 검사 예외 클래스에 제공하자.

**프로그래밍 오류를 나타낼 때는 `런타임 예외(비검사 예외)`를 사용하자.** 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. 이 경우 복구가 불가능하거나, 더 실행해봐야 득보다는 실이 많다는 뜻이다. 예를 들어 `ArrayIndexOutOfBoundsException`이 발생했다는 건 배열의 인덱스 전제조건을 지키지 않았다는 뜻이고 복구 불가능하다는 뜻이다. 복구 가능하다고 확신하기 어렵다면 비검사 예외를 선택하자.

**`Error`, `Throwable`은 사용하지 않도록 한다.** Api 사용자들을 헷갈리게 할 뿐이다.